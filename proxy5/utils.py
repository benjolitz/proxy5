'''utils -- contains utility/support members.

CertificateAuthority: class for faking SSL keys for any site
safe_split_http_response_line - parse HTTP response codes
safe_split_http_request_line - parse HTTP request
'''
import shutil
import os
import logging
import tempfile
import uuid
try:
    import urlparse
except ImportError:
    import urllib.parse as urlparse
import time
from collections import namedtuple
import string


from OpenSSL.crypto import (X509Extension, X509, dump_privatekey,
                            dump_certificate, load_certificate,
                            load_privatekey, PKey, TYPE_RSA, X509Req)
from OpenSSL.SSL import FILETYPE_PEM
HTTPMethod = namedtuple("HTTPMethod", 'method path version')
DEFAULT_METHOD = {'method': b'GET', 'path': b'/', 'version': b'HTTP/1.0'}
DEFAULT_RESPONSE = {'version': b'HTTP/1.1', 'code': 200, 'message': b'OK'}
HTTP_REQUEST_FIELDS = (('method', lambda x: x.upper()),
                       ('path', lambda x: x),
                       ('version', lambda x: x.upper()))
HTTPResponse = namedtuple("HTTPResponse", "version code message")
HTTP_RESPONSE_FIELDS = \
    (('version', lambda x: x.upper()),
     ('code', int), ('message', lambda x: x))
ACCEPTABLE_HTTP_METHODS = \
    (b'GET', b'PUT', b'POST', b'HEAD', b'DELETE',
     b'CONNECT', b'OPTIONS', b'TRACE', b'PATCH')

HORRIBLE_HTTP_CODE = "Failed to split line: {0!r} for a http code"
ACCEPTABLE_HTTP_VERSIONS = (b'HTTP/1.1', b'HTTP/1.0', b'HTTP/0.9')
WHITESPACE = string.whitespace.encode('ascii')


class FakeLogging(object):
    INFO = DEBUG = WARN = CRITICAL = 0

    def getLogger(self, name):
        return FakeLogger(name)

    def StreamHandler(self):
        return FakeLogger(None)

    def Formatter(self, *args):
        return FakeLogger(None)


IDENTITY_FUNC = lambda *args: x


class FakeLogger(object):
    def __init__(self, name):
        self.name = name
        self.handlers = []

    def addHandler(self, h):
        self.handlers.append(h)

for x in ('setLevel', 'warning', 'warn', 'info',
          'debug', 'exception', 'setFormatter'):
    setattr(FakeLogger, x, IDENTITY_FUNC)


class CertificateAuthority(object):
    '''CA generator from pymiproxy.
    Originally by: Nadeem Douba
    Original Copyright: Copyright 2012, PyMiProxy Project

    Modified by Ben Jolitz to be less secure in the
    interests of speed in the use case of intercepting traffic
    meant for PhantomJS.

    Purposely uses weak ciphers.
    '''
    KEY_STRENGTH = 1024  # bits
    DEFAULT_CA_FILE = os.path.join(
        os.path.dirname(
            os.path.abspath(__file__)),
        'hydra_proxy_private_key.pem')

    def __init__(self, ca_file=None, cache_dir=None, logger=None):
        self.logger = None
        if logger:
            try:
                self.logger = logging.getLogger(
                    logger.name + '.CertificateAuthority')
            except AttributeError:
                self.logger = None
        self.ca_file = ca_file or self.DEFAULT_CA_FILE
        self._cache_dir_autogenerated = False
        self.cache_dir = cache_dir or self.generate_uniq_cache_dir()
        self.artificial_certs = set()
        self._serial = self._get_serial()

        if not os.path.exists(self.ca_file):
            self._generate_ca()
        else:
            self._read_ca(self.ca_file)

    def generate_uniq_cache_dir(self):
        cache_dir = None
        self._cache_dir_autogenerated = True
        while True:
            tempdir = os.path.join(
                tempfile.gettempdir(),
                ''.join(
                    ('hydra-certs-', str(uuid.uuid1()), str(time.time()),)
                ))
            if not os.path.exists(tempdir):
                os.mkdir(tempdir)
            cache_dir = tempdir
            break
        if self.logger:
            self.logger.debug(
                "Generated cert directory at {0}".format(cache_dir))
        return cache_dir

    def _get_serial(self):
        s = 1
        c = None
        for c in (x for x in os.listdir(self.cache_dir)
                  if x.startswith('fake_ssl_cert_hydra_')):
            with open(os.path.sep.join([self.cache_dir, c])) as fh:
                sc = load_certificate(
                    FILETYPE_PEM, fh.read()).get_serial_number()
                if sc > s:
                    s = sc
            c = None
        return s

    def _generate_ca(self):
        # Generate key
        self.key = PKey()
        self.key.generate_key(TYPE_RSA, self.KEY_STRENGTH)

        # Generate certificate
        self.cert = X509()
        self.cert.set_version(3)
        self.cert.set_serial_number(1)
        self.cert.get_subject().CN = \
            b'nothing.com'
        self.cert.gmtime_adj_notBefore(0)
        self.cert.gmtime_adj_notAfter(315360000)
        self.cert.set_issuer(self.cert.get_subject())
        self.cert.set_pubkey(self.key)
        self.cert.add_extensions([
            X509Extension(b"basicConstraints", True, b"CA:TRUE, pathlen:0"),
            X509Extension(b"keyUsage", True, b"keyCertSign, cRLSign"),
            X509Extension(b"subjectKeyIdentifier", False, b"hash",
                          subject=self.cert),
        ])
        self.cert.sign(self.key, b"sha1")

        with open(self.ca_file, 'wb+') as f:
            f.write(dump_privatekey(FILETYPE_PEM, self.key))
            f.write(dump_certificate(FILETYPE_PEM, self.cert))
        if self.logger:
            self.logger.debug(
                "Generated client-side certificate {0}".format(self.ca_file))

    def _read_ca(self, file):
        with open(file) as fh:
            content = fh.read()
        self.cert = load_certificate(FILETYPE_PEM, content)
        self.key = load_privatekey(FILETYPE_PEM, content)

    def __getitem__(self, domain):
        cnp = os.path.join(
            self.cache_dir,
            'fake_ssl_cert_sitemon_%s.pem' % domain)
        if not os.path.exists(cnp):
            # create certificate
            key = PKey()
            # Generate a WEAK key. -- btj
            key.generate_key(TYPE_RSA, self.KEY_STRENGTH)

            # Generate CSR
            req = X509Req()
            while len(domain) > 63:
                self.logger and self.logger.debug(
                    "Domain Error: {1} length too long {0} > 63".format(
                        len(domain)), domain)
                domain = b'.'.join(domain.split(b'.')[1:])
            try:
                req.get_subject().CN = domain
            except Exception:
                self.logger and \
                    self.logger.exception(
                        ("Failure to set domain of fake "
                         "cert for domain {0}").format(domain))
                raise
            req.set_pubkey(key)
            req.sign(key, 'sha1')

            # Sign CSR
            cert = X509()
            cert.set_subject(req.get_subject())
            cert.set_serial_number(self.serial)
            cert.gmtime_adj_notBefore(0)
            cert.gmtime_adj_notAfter(31536000)
            cert.set_issuer(self.cert.get_subject())
            cert.set_pubkey(req.get_pubkey())
            cert.sign(self.key, 'sha1')

            with open(cnp, 'wb+') as f:
                f.write(dump_privatekey(FILETYPE_PEM, key))
                f.write(dump_certificate(FILETYPE_PEM, cert))
            self.artificial_certs.add(cnp)

        return cnp

    @property
    def serial(self):
        self._serial = uuid.uuid1().int
        return self._serial

    def cleanup(self):
        '''Automatically scrub out generated certs. We don't lose
        much in making them, but we're not gonna like a messy
        tmp'''
        for item in self.artificial_certs:
            try:
                os.remove(item)
            except Exception as e:
                self.logger and self.logger.warning(
                    "Cannot remove client cert: {0}, Cause {1}".format(
                        item, e))
        if self.cache_dir and self._cache_dir_autogenerated:
            try:
                shutil.rmtree(self.cache_dir)
            except Exception as e:
                self.logger and self.logger.warning(
                    "Cannot remove generated cache dir: {0}, Cause {1}".format(
                        self.cache_dir, e))
            self.cache_dir = None
        if self.ca_file and self.ca_file != self.DEFAULT_CA_FILE:
            try:
                os.remove(self.ca_file)
            except Exception as e:
                self.logger and self.logger.warning(
                    "Cannot remove ca_file: {0}. Cause: {1}".format(
                        self.ca_file, e))
            self.ca_file = None


def safe_split_http_request_line(line, force_version=None, pathify_url=False):
    '''
    A tolerant HTTP command splitter. It goes character by character
    and splits based upon string.whitespace.

    >>> safe_split_http_request_line(b'GET / HTTP/1.1')[0]
    HTTPMethod(method='GET', path='/', version='HTTP/1.1')
    >>> safe_split_http_request_line(b'GET /foo/bar/blech?x=%20:4 HTTP/1.1')[0]
    HTTPMethod(method='GET', path='/foo/bar/blech?x=%20:4', version='HTTP/1.1')
    >>> safe_split_http_request_line('GET /foo/bar/blech?x=%20:4')[0]
    HTTPMethod(method='GET', path='/foo/bar/blech?x=%20:4', version='HTTP/1.0')
    >>> safe_split_http_request_line('GET /foo/bar/blech?x=%20:4 ')[0]
    HTTPMethod(method='GET', path='/foo/bar/blech?x=%20:4', version='HTTP/1.0')

    Illegal lines:
    >>> safe_split_http_request_line('GET')
    Traceback (most recent call last):
      File "<console>", line 1, in <module>
      File "<console>", line 39, in safe_split_http_request_line
    ValueError: Invalid line. Expected a valid path
    >>> safe_split_http_request_line('ILLEGAL /foo/bar/blech?x=%20:4 ')
    Traceback (most recent call last):
      File "<console>", line 1, in <module>
      File "<console>", line 43, in safe_split_http_request_line
    ValueError: Invalid line. Expected a valid method
    '''
    if not isinstance(line, bytes):
        line = line.encode('utf8')
    values = {}
    queue = []
    index = 0
    while line:
        char, line = line[:1], line[1:]
        if char in WHITESPACE or not line:
            if not line:
                queue.append(char)
            field, postprocesser = HTTP_REQUEST_FIELDS[index]
            values[field] = postprocesser(b''.join(queue).strip())
            queue[:] = []
            index += 1
            continue
        queue.append(char)
    try:
        if values['method'] not in ACCEPTABLE_HTTP_METHODS:
            raise KeyError('method')
        if 'version' in values and values['version'] not in \
                ACCEPTABLE_HTTP_VERSIONS:
            raise KeyError('version')
        if 'path' not in values:
            raise KeyError('path')
    except KeyError as e:
        if e.args[0] in ('method', 'version', 'path'):
            raise ValueError(
                "Invalid line. Expected a valid {0}".format(e))
        else:
            raise
    if force_version:
        values['version'] = force_version
    original_path = values.get('path', DEFAULT_METHOD['path'])
    if 'path' in values and pathify_url and \
            values.get(
                'method', DEFAULT_METHOD['method']).lower() != b'connect':
        values['path'] = urlparse.urlunparse(
            (b'', b'') + urlparse.urlparse(values['path'])[2:])
    final_dict = dict(DEFAULT_METHOD, **values)
    return HTTPMethod(
        final_dict['method'], final_dict['path'],
        final_dict['version']), original_path


def safe_split_http_response_line(line):
    '''
    >>> safe_split_http_response_line(b"HTTP/1.1 200 OK")
    HTTPResponse(version='HTTP/1.1', code=200, message='OK')
    >>> safe_split_http_response_line(b"HTTP/1.1    200\tOK")
    HTTPResponse(version='HTTP/1.1', code=200, message='OK')
    >>> safe_split_http_response_line(b"HTTP/1.1200\tOK")
    Traceback (most recent call last):
      File "<console>", line 1, in <module>
      File "<console>", line 43, in safe_split_http_request_line
    ValueError: invalid literal for int() with base 10: 'OK'
    >>> safe_split_http_response_line(b"HTTP/1.0 204 No Content")
    HTTPResponse(version='HTTP/1.0', code=204, message='No Content')
    '''
    values = {}
    queue = []
    index = 0
    while line:
        char, line = line[:1], line[1:]
        if char in WHITESPACE or not line:
            if not line:
                queue.append(char)
            if queue:
                field, postprocesser = HTTP_RESPONSE_FIELDS[index]
                values[field] = postprocesser(b''.join(queue).strip())
                if index < 2:
                    index += 1
                    queue[:] = []
                else:
                    queue.append(char)
            continue
        queue.append(char)
    return HTTPResponse(**dict(DEFAULT_RESPONSE, **values))
